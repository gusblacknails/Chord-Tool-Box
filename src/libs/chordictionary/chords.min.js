import { NOTES } from "./notes.min"
import { DIATONIC } from "./interval.min"
import { WORDING } from "./wordings.min"
export const FORMULAS = [
  { formula: "1-3-5", integer: "0-4-7", name: "Major", suffix: "" },
  { formula: "1-3-5#", integer: "0-4-8", name: "Augmented", suffix: "aug" },
  { formula: "1-b3-b5", integer: "0-3-6", name: "Diminished", suffix: "dim" },
  { formula: "1-b3-5", integer: "0-3-7", name: "Minor", suffix: "min" },
  {
    formula: "1-b3-5-9",
    integer: "0-2-3-7",
    name: "Minor, added ninth",
    suffix: "m(add9)",
  },
  {
    formula: "1-3-4-5",
    integer: "0-4-5-7",
    name: "Added fourth",
    suffix: "add4",
  },
  {
    formula: "1-4-5",
    integer: "0-5-7",
    name: "Suspended fourth",
    suffix: "sus4",
  },
  {
    formula: "1-2-5",
    integer: "0-2-7",
    name: "Suspended second",
    suffix: "sus2",
  },
  {
    formula: "1-3-5-9",
    integer: "0-2-4-7",
    name: "Added ninth",
    suffix: "add9",
  },
  { formula: "1-3-b7", integer: "0-4-10", name: "Seventh", suffix: "7" },
  {
    formula: "1-3-5-b7",
    integer: "0-4-7-10",
    name: "Dominant seventh",
    suffix: "7",
  },
  {
    formula: "1-3-5-7",
    integer: "0-4-7-11",
    name: "Major seventh",
    suffix: "Maj7",
  },
  {
    formula: "1-b3-5-7",
    integer: "0-3-7-11",
    name: "Minor, major seventh",
    suffix: "m(Maj7)",
  },
  {
    formula: "1-b3-5-b7",
    integer: "0-3-7-10",
    name: "Minor seventh",
    suffix: "m7",
  },
  {
    formula: "1-b3-b5-b7",
    integer: "0-3-6-10",
    name: "Minor seventh, flat fifth",
    suffix: "m7b5",
  },
  { formula: "1-3-6", integer: "0-4-9", name: "Sixth", suffix: "6" },
  {
    formula: "1-b3-5-6",
    integer: "0-3-7-9",
    name: "Minor sixth",
    suffix: "m6",
  },
  {
    formula: "1-b3-5-b6",
    integer: "0-3-7-8",
    name: "Minor, flat sixth",
    suffix: "mb6",
  },
  {
    formula: "1-b3-5-6-9",
    integer: "0-2-3-7-9",
    name: "Minor sixth, added ninth",
    suffix: "m6/9",
  },
  {
    formula: "1-3-5-6",
    integer: "0-4-7-9",
    name: "Major Sixth",
    suffix: "Maj6",
  },
  {
    formula: "1-3-5-6-9",
    integer: "0-2-4-7-9",
    name: "Sixth, added ninth",
    suffix: "6/9",
  },
  {
    formula: "1-3-5-7-9",
    integer: "0-2-4-7-11",
    name: "Major ninth",
    suffix: "Maj9",
  },
  {
    formula: "1-b3-5-b7-9",
    integer: "0-2-3-7-10",
    name: "Minor ninth",
    suffix: "m9",
  },
  {
    formula: "1-b3-5-7-9",
    integer: "0-2-3-7-11",
    name: "Minor ninth, major seventh",
    suffix: "m9(Maj7)",
  },
  {
    formula: "1-b3-b5-b7-9",
    integer: "0-2-3-6-10",
    name: "Minor ninth flat fifth",
    suffix: "m9b5",
  },
  {
    formula: "1-3-5-7-9-11",
    integer: "0-4-5-11",
    name: "Major eleventh (no fifth, no ninth)",
    suffix: "Maj11",
  },
  {
    formula: "1-3-5-7-9-11",
    integer: "0-4-5-7-11",
    name: "Major eleventh (no ninth)",
    suffix: "Maj11",
  },
  {
    formula: "1-3-5-7-9-11",
    integer: "0-2-4-5-7-11",
    name: "Major eleventh",
    suffix: "Maj11",
  },
  {
    formula: "1-b3-5-b7-9-11-13",
    integer: "0-2-3-4-6-7-10",
    name: "Minor thirteen",
    suffix: "m13",
  },
  {
    formula: "1-3-5-b7-#11",
    integer: "0-4-6-7-10",
    name: "Seventh, sharp eleventh",
    suffix: "7#11",
  },
  {
    formula: "1-3-5-7-#11",
    integer: "0-4-6-7-11",
    name: "Major seventh, sharp eleventh",
    suffix: "Maj7#11",
  },
  {
    formula: "1-3-5-7-9-13",
    integer: "0-2-4-7-9-11",
    name: "Major thirteen",
    suffix: "Maj13",
  },
  { formula: "1", integer: "0", name: "Single note", suffix: "" },
  { formula: "1-5", integer: "0-7", name: "Power chord", suffix: "5" },
]
const NAMING = {
  powerchord: ["5", "5 (powerchord)"],
  major: ["Maj", "Major"],
  minor: ["min", "Minor"],
  sharp5: ["#5", "Sharp 5th"],
  sharp11: ["#11", "Sharp 11th"],
  aug5: ["aug", "Augmented"],
  dim5: ["dim", "Diminished"],
  flat5: ["b5", "Flat 5th"],
  flat9: ["b9", "Flat 9th"],
  doubleflat5: ["bb5", "Double Flat 5th"],
  sus2: ["sus2", "Suspended 2nd"],
  sus4: ["sus4", "Suspended 4th"],
  b6: ["b6", "Flat 6th"],
  add2: ["add2", "Added 2nd"],
  add4: ["add4", "Added 4th"],
  addflat5: ["addb5", "Added Flat 5th"],
  add9: ["add9", "Added 9th"],
  major9: ["Maj9", "Major 9"],
  nine: ["9", "9th"],
  six: ["6", "6th"],
  sixnine: ["6/9", "Six Added Ninth"],
  seven: ["7", "7th"],
  major7: ["Maj7", "Major 7th"],
  eleven: ["11", "11th"],
  thirteen: ["13", "13th"],
}
export function isValid(e, n, i) {
  let a,
    r,
    t = {}
  for (let a = 0; a < e.length; a++)
    if (!isNaN(e[a])) {
      ;(r = e[a] + NOTES.indexOf(i[a])) > NOTES.length - 1 &&
        (r -= NOTES.length)
      for (let e = 0; e < n.length; e++)
        t[NOTES[r]] ? NOTES[r] === NOTES[e] && t[NOTES[r]]++ : (t[NOTES[r]] = 1)
    }
  for (let e = 0; e < n.length; e++) {
    if (!(n[e] in t)) {
      a = !1
      break
    }
    a = !0
  }
  return a
}
export function parse(e) {
  let n, i
  try {
    if ("string" != typeof e) throw WORDING.invalidChordName
    return (
      -1 === e.search("#")
        ? ((n = e.charAt(0)), (i = e.slice(1)))
        : ((n = e.slice(0, 2).toUpperCase()), (i = e.slice(2))),
      [n, i]
    )
  } catch (e) {
    return !1
  }
}
export function name(e) {
  let n = e.map(e => DIATONIC[e]).filter(e => void 0 !== e),
    i = n.filter(e => ["2"].includes(e)).length,
    a = {
      seven: n.some(e => ["b7", "7"].includes(e)),
      third: n.some(e => ["b3", "3"].includes(e)),
      fifth: n.some(e => ["b5", "5", "#5"].includes(e)),
      majorNinth:
        n.includes("2") && !(!n.some(e => ["b3", "3"].includes(e)) && i < 2),
    },
    r = [
      {
        name: "powerchord",
        check: n.includes("5") && n.every(e => ["1", "5"].includes(e)),
      },
      {
        name: "major",
        check:
          n.includes("3") &&
          !n.some(e => ["6", "4"].includes(e) || a.seven || a.majorNinth),
      },
      { name: "minor", check: n.includes("b3") },
      {
        name: "aug5",
        check: n.includes("#5") && n.includes("3") && !n.includes("5"),
      },
      {
        name: "dim5",
        check:
          n.includes("b5") &&
          n.includes("b3") &&
          !n.includes("5") &&
          !a.seven &&
          !a.majorNinth,
      },
      {
        name: "seven",
        check:
          n.includes("b7") &&
          !n.some(e => ["6", "b9", "9"].includes(e) || a.majorNinth),
      },
      {
        name: "major7",
        check:
          n.includes("7") &&
          !n.some(e => ["6", "4"].includes(e) || a.majorNinth),
      },
      {
        name: "major9",
        check: a.majorNinth && n.includes("7") && !n.includes("6"),
      },
      { name: "six", check: n.includes("6") && !a.seven },
      { name: "nine", check: a.majorNinth && n.includes("b7") },
      { name: "eleven", check: n.includes("4") && a.seven && !n.includes("6") },
      { name: "thirteen", check: n.includes("6") && a.seven },
      {
        name: "add2",
        check: a.majorNinth && a.third && !a.seven && !n.includes("6"),
      },
      { name: "add4", check: a.third && n.includes("4") && !a.seven },
      { name: "add9", check: a.majorNinth && a.third && !a.seven },
      { name: "sus2", check: n.includes("2") && !a.third },
      { name: "sus4", check: n.includes("4") && !a.third && !a.seven },
      {
        name: "sharp5",
        check: n.includes("#5") && !n.some(e => ["5", "3"].includes(e)),
      },
      {
        name: "flat5",
        check: n.includes("b5") && !n.some(e => ["5"].includes(e)),
      },
      {
        name: "addflat5",
        check: ["5", "b5"].every(e => n.includes(e)) && !a.seven,
      },
      {
        name: "sharp11",
        check: ["5", "b5"].every(e => n.includes(e)) && a.seven,
      },
      { name: "flat9", check: n.includes("b2") && a.third },
      { name: "b6", check: n.includes("#5") && n.includes("5") },
      {
        name: "doubleflat5",
        check: n.includes("4") && a.third && !a.fifth && !a.seven,
      },
    ],
    t = {
      add2: "add9",
      seven: "eleven",
      nine: "eleven",
      minor: "dim5",
      flat5: "dim5",
      major: "aug5",
    },
    s = r.filter(e => e.check).map(e => e.name)
  return (
    s.length > 0 &&
    ((s = s.filter(e => !s.includes(t[e]))),
    ["six", "add9"].every(e => s.includes(e)) &&
      (s.splice(s.indexOf("six"), 1), (s[s.indexOf("add9")] = "sixnine")),
    {
      semitones: e,
      formula: n,
      qualityS: s.map(e => NAMING[e][0]),
      qualityL: s.map(e => NAMING[e][1]),
    })
  )
}
